#!/usr/bin/env python

__author__="Sergio Maffioletti (sergio.maffioletti@gc3.uzh.ch)"
__date__="01 January 2009"
__copyright__="Copyright 2009 2011 Grid Computing Competence Center - UZH/GC3"
__version__="0.1a"

import sys
import os
import ConfigParser
from optparse import OptionParser
import logging
from gc3utils import campusgrid
from gc3utils.campusgrid import *

default_config_file_location="$HOME/.gc3/config"
default_job_folder_location="$PWD"
resource_list = {}
defaults = {}

def generate_unique_token_old():
  # should return unique token
  global default_job_folder_location
  
  _retval = commands.getstatusoutput("echo uzhgc3_$$")
  default_job_folder_location = os.path.expandvars(default_job_folder_location)
  
  
  if ( _retval[0] != 0 ):
    logging.error("Create unique token\t\t\t\t[ failed ]")
    raise

  # Valid Unique Token created
  return _retval[1]

def select_lrms(lrms_list):
  return 0

def readConfig(config_file_location):

  global defaults
  global resource_list


  try:
    _configFileLocation = os.path.expandvars(config_file_location)
    if ( os.path.exists(_configFileLocation) & os.path.isfile(_configFileLocation) ):
      # Config File exists; read it
      config = ConfigParser.ConfigParser()
      config.readfp(open(_configFileLocation))
      defaults = config.defaults()

      _resources = config.sections()
      for _resource in _resources:
        _option_list = config.options(_resource)
        _resource_options = {}
        for _option in _option_list:
          _resource_options[_option] = config.get(_resource,_option)
        _resource_options['resource_name'] = _resource
        resource_list[_resource] = _resource_options
      return 0
    else:
      logging.error('config file [%s] not found or not readable ',_configFileLocation)
      raise
  except:
    logging.error('Exception in readConfig')
    raise

def check_file(file_uri):
  if ( os.path.exists(file_uri) & os.path.isfile(file_uri) ):
    return 0
  else:
    return 1

def main():

  global default_job_folder_location

  try:
    # Parse command line arguments
    _usage = "Usage: %prog [options] application input-file"
    parser = OptionParser(usage=_usage)
    parser.add_option("-v", action="count", dest="verbosity", default=0, help="Set verbosity level")
    parser.add_option("-r", "--resource", action="store", dest="resource_name", metavar="STRING", default="", help='Select resource destination')
    
    (options, args) = parser.parse_args()

    # Configure logging service
    if ( options.verbosity > 5):
      _logging_level = 10
      #  elif ( options.verbosity == 0 ):
      #    _logging_level = 70
    else:
      _logging_level = (( 6 - options.verbosity) * 10)

    logging.basicConfig(level=_logging_level, format='%(levelname)-8s : %(message)s')

    if len(args) != 2: 
      logging.critical('Command line argument parsing\t\t\t[ failed ]\n\tIncorrect number of arguments; expected 2 got %d ',len(args))
      parser.error('wrong number on arguments')
      parser.print_help()
      raise
    
    # Checking whether it has been passed a valid application
    if ( args[0] != "gamess" ) & ( args[0] != "apbs" ):
      logging.critical('Application argument\t\t\t[ failed ]\n\tUnknown application: '+str(args[0]))
      raise

    # check input file
    if ( not check_inputfile(args[1]) ):
      logging.critical('Input file argument\t\t\t[ failed ]'+args[1])
      raise

    _application_to_run = args[0]
    _input_file = args[1]
    logging.debug('Defined arguments as: application [%s], inputfile [%s]',_application_to_run,_input_file)

    logging.info('Parsing command line arguments\t\t[ ok ]')

    # read configuration file
    if ( readConfig(default_config_file_location) != 0 ):
      logging.critical('Loading configuration file\t\t\t[ failed ]')
      raise

    logging.info('Loading configuration file\t\t\t[ ok ]')

    try:

      _lrms_list = []

      if ( options.resource_name != "" ):
        if ( options.resource_name in resource_list ):
          logging.debug('Found match for user defined resource: %s',options.resource_name)
          candidate_resource = [resource_list[options.resource_name]]
        else:
          logging.critical('Failed finding matching fir user defined resources: %s ',options.resource_name)
          raise

        logging.info('Check user defined resources\t\t\t[ ok ]')

      else:
        candidate_resource = resource_list.values()
      logging.debug('Creating list of lrms instances')

      for resource in candidate_resource:
        logging.debug('Creating instance of type %s for %s',resource['type'],resource['frontend'])
        if ( resource['type'] == "arc" ):
          lrms = ArcLrms(resource)
        elif ( resource['type'] == "ssh"):
          lrms = SshLrms(resource)
        else:
          logging.error('Unknown resource type %s',resource['type'])
          continue

        if ( (lrms.isValid == 1) & (lrms.check_authentication() == 0) ):
          _lrms_list.append(lrms)
        else:
          logging.error('Failed validating lrms instance for resource %s',resource['resource_name'])

      if ( len(_lrms_list) == 0 ):
        logging.critical('Could not initialize ANY lrms resource')
        raise

      logging.info('Init pool of LRMS resources \t\t\t[ ok ]')

      # End of for loop
      # check that qgms is a good version
      minimum_version = 0.1
      check_qgms_version(minimum_version)

      # check_input
      check_inputfile(_input_file)
      
      # decide which resource to use()
      selected_lrms = select_lrms(_lrms_list)
      lrms = _lrms_list[selected_lrms]

      logging.debug('Selected LRMS: %s',selected_lrms)
      logging.info('Select LRMS\t\t\t\t\t[ ok ]')

      # _dirname is basedir of inputfile
      # _inputname is the input name of te inputfile (e.g. exam01 from exam01.inp)
      # _inputfilename is the basename of the inputfile
      _dirname = dirname(_input_file)
      _inputname = inputname(_input_file)
      _inputfilename = inputfilename(_input_file)

      # generate_unique_token()
      unique_token = create_unique_token(_input_file,resource['resource_name'])

      logging.debug('Generate Unique token: %s',unique_token)
      logging.info('Generate Unique token\t\t\t[ ok ]')
            

      # creating folder for job's session
      default_job_folder_location = os.path.expandvars(default_job_folder_location)

      logging.debug('proceeding')
      
      logging.debug('creating folder for job session: %s/%s',default_job_folder_location,unique_token)
      os.mkdir(default_job_folder_location+'/'+unique_token)

      logging.info('Create job folder\t\t\t[ ok ]')

      lrms_log = None
      lrms_jobid = None

      # resource_name.submit_job(input, unique_token, application, lrms_log) -> returns lrms_jobid
      logging.debug('Submitting job with %s %s %s %s',unique_token, _application_to_run, _input_file, defaults['lrms_log'])
      (lrms_jobid,lrms_log) = lrms.submit_job(unique_token, _application_to_run, _input_file)

      logging.info('Submission process to LRMS backend\t\t\t[ ok ]')

      # dump lrms_log
      logging.debug('Dumping lrms_log and lrms_jobid')
      _fileHandle = open(default_job_folder_location+'/'+unique_token+'/'+defaults['lrms_log'],'a')
      _fileHandle.write(lrms_log+'\n')
      _fileHandle.close()

      if ( lrms_jobid == None ):
        logging.critical('Submit to LRMS\t\t\t[ failed ]')
        raise      
      else:
        logging.info('Submit to LRMS\t\t\t\t[ ok ]')

        # dumping lrms_jobid
        _fileHandle = open(default_job_folder_location+'/'+unique_token+'/'+defaults['lrms_jobid'],'w')
        _fileHandle.write(lrms.resource['resource_name']+'\t'+lrms_jobid)
        _fileHandle.close()

        logging.info('Dumping lrms log information\t\t\t[ ok ]')

        print default_job_folder_location+'/'+unique_token

        return 0

    except:
      raise
  except:
    logging.info('%s',sys.exc_info()[1])
    sys.stderr.write('Command failure\n')
    sys.stderr.flush()
    return 1
  
if __name__ == "__main__":
  sys.exit(main())

